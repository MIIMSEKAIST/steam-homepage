<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>전류 변수 사이클 수명 예측 — STEAM Project Hub</title>
  <meta name="description" content="상수 프로토콜(C1, %, C2)과 증가 Cycle, 초기 용량 C₀를 바탕으로 CNN-LSTM + LGBM 조합으로 수명 곡선을 롤아웃 예측" />
  <!-- 라이트 톤 상단바 고정 -->
  <meta name="theme-color" content="#f7f9fc" />
  <style>
    :root{
      /* 라이트 팔레트 고정 (model-temp-life와 동일) */
      --bg:#f7f9fc; --fg:#0d1117; --muted:#536075; --card:#ffffff; --border:#e6eaf1;
      --accent:#3b82f6; --accent2:#14b8a6; --shadow:0 10px 30px rgba(0,0,0,.10); --r:18px;
      --ease:cubic-bezier(.16,1,.3,1);
      color-scheme: light; /* 브라우저 위젯/폼/스크롤바도 라이트 */
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; background:var(--bg); color:var(--fg); font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",Arial}
    a{color:inherit; text-decoration:none}
    .container{width:min(100%,1100px); margin:0 auto; padding:24px 20px}

    /* 상단바/브레드크럼/히어로 (temp-life와 동일 레이아웃) */
    header{position:sticky; top:0; z-index:5; backdrop-filter:saturate(120%) blur(8px);
      background:color-mix(in srgb,var(--bg),transparent 20%); border-bottom:1px solid var(--border)}
    .nav{display:flex; align-items:center; justify-content:space-between; height:64px}
    .brand{display:flex; align-items:center; gap:10px; font-weight:800}
    .mark{width:28px; height:28px; border-radius:8px; background:linear-gradient(135deg,var(--accent),var(--accent2))}
    .crumbs{display:flex; gap:8px; align-items:center; font-size:14px; color:var(--muted)}
    .crumbs a{color:var(--muted)}
    .hero{padding:26px 0}
    .hero h1{margin:0 0 8px; font-size:clamp(22px,4.2vw,34px); line-height:1.15}
    .hero p{margin:0; color:var(--muted)}

    /* 그리드/카드 */
    .grid{display:grid; gap:18px; grid-template-columns:1fr; align-items:start; margin-top:14px}
    @media (min-width:980px){ .grid{ grid-template-columns: 1.05fr .95fr; } }

    .card{background:var(--card); border:1px solid var(--border); border-radius:var(--r); box-shadow:var(--shadow); overflow:hidden}
    .card header{display:flex; align-items:center; justify-content:space-between; padding:14px 16px; border-bottom:1px solid var(--border)}
    .card header h2{margin:0; font-size:18px}
    .card .body{padding:16px}

    /* 폼/버튼 (temp-life 스타일) */
    .row{display:grid; gap:12px; grid-template-columns: 1fr}
    @media (min-width:720px){ .row.cols-3{ grid-template-columns: 1fr 1fr 1fr; } .row.cols-2{ grid-template-columns: 1 fr 1fr; } }

    .label{font-size:13px; color:var(--muted); margin-bottom:6px}
    .field{position:relative}
    .field input[type="number"],
    .field select,
    .field button{
      width:100%; padding:12px 14px; border-radius:12px; background:color-mix(in srgb,var(--card),transparent 8%);
      border:1px solid var(--border); color:var(--fg); outline:none;
      transition: border-color .2s var(--ease), box-shadow .2s var(--ease);
    }
    input::placeholder{color:color-mix(in srgb,var(--muted),transparent 30%)}
    input:focus, select:focus{border-color:color-mix(in srgb,var(--accent),transparent 40%); box-shadow:0 0 0 3px color-mix(in srgb,var(--accent),transparent 85%)}

    .actions{display:flex; gap:10px; flex-wrap:wrap; margin-top:14px}
    .btn{display:inline-flex; align-items:center; gap:8px; padding:10px 14px; border-radius:12px; border:1px solid var(--border); cursor:pointer}
    .btn.primary{background:linear-gradient(180deg,var(--accent),#6b86ff); color:#fff; border-color:transparent}
    .btn.ghost{background:transparent; color:var(--fg)}
    .hint{font-size:12px; color:var(--muted)}
    .warn{font-size:12px; color:#d92b2b; min-height:1.2em}

    /* 차트/통계/테이블 (temp-life 스타일) */
    .chart-wrap{border:1px solid var(--border); border-radius:12px; padding:12px; margin-bottom:12px}
    canvas{display:block; width:100%; height:260px}

    .stats{display:grid; gap:10px; grid-template-columns:1fr; margin-bottom:10px}
    @media (min-width:720px){ .stats{ grid-template-columns: repeat(3, 1fr); } }
    .stat{border:1px solid var(--border); border-radius:12px; padding:12px}
    .stat .k{font-size:12px; color:var(--muted)}
    .stat .v{font-size:18px; font-weight:700}

    table{width:100%; border-collapse:separate; border-spacing:0; border:1px solid var(--border); border-radius:12px; overflow:hidden}
    thead th{font-size:12px; color:var(--muted); text-align:left; padding:10px}
    tbody td{padding:10px; border-top:1px solid var(--border)}
    tbody tr:hover{background:color-mix(in srgb,var(--card),transparent 12%)}
  </style>
</head>
<body>
  <header>
    <div class="container nav">
      <div class="brand"><span class="mark" aria-hidden="true"></span> STEAM Project Hub</div>
      <nav aria-label="보조">
        <a href="index.html" style="font-size:14px; color:var(--muted)">← 홈으로</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <div class="crumbs"><a href="index.html">홈</a> › <span>머신러닝</span> › <span>전류 변수 사이클 수명 예측</span></div>

    <section class="hero">
      <h1>전류 변수 사이클 수명 예측 모델</h1>
      <p class="muted">C1, Percentage(%), C2는 고정, Cycle은 시작값부터 1씩 증가한다고 가정. 초기 용량 C₀를 기준으로 예측 곡선을 앵커링(1점/2점)해 롤아웃.</p>
    </section>

    <section class="grid">
      <!-- 입력 카드 -->
      <article class="card">
        <header><h2>입력</h2></header>
        <div class="body">
          <div class="row cols-3">
            <div class="field">
              <div class="label">C1</div>
              <input id="C1" type="number" step="any" placeholder="예: 1.0" />
            </div>
            <div class="field">
              <div class="label">Percentage (%)</div>
              <input id="PCT" type="number" step="any" placeholder="예: 90 (0~100)" />
            </div>
            <div class="field">
              <div class="label">C2</div>
              <input id="C2" type="number" step="any" placeholder="예: 0.5" />
            </div>
          </div>

          <div class="row cols-3">
            <div class="field">
              <div class="label">시작 Cycle</div>
              <input id="CY0" type="number" step="1" value="1" />
            </div>
            <div class="field">
              <div class="label">초기 윈도우 길이 (고정 100)</div>
              <input id="SEQ" type="number" step="1" value="100" />
            </div>
            <div class="field">
              <div class="label">롤아웃 스텝 수</div>
              <input id="STEPS" type="number" step="1" value="800" />
            </div>
          </div>

          <div class="row cols-3">
            <div class="field">
              <div class="label">초기 방전 용량 C₀ (Ah)</div>
              <input id="C0" type="number" step="any" placeholder="예: 2.30" />
            </div>
            <div class="field">
              <div class="label">앵커링</div>
              <select id="anchor">
                <option value="first">1점: 첫 예측을 C₀에 맞춤</option>
                <option value="two">2점: EOL(0.8×C₀)에서 재보정</option>
              </select>
            </div>
            <div class="field">
              <div class="label">EOL 비율</div>
              <input id="EOL" type="number" step="0.01" value="0.80" />
            </div>
          </div>

          <div class="actions">
            <button class="btn primary" id="runBtn" type="button">실행</button>
            <button class="btn" id="demoBtn" type="button">데모 채우기</button>
            <button class="btn" id="clearBtn" type="button">초기화</button>
          </div>
          <div id="warn" class="warn"></div>
        </div>
      </article>

      <!-- 출력 카드 -->
      <article class="card" id="outCard">
        <header><h2>출력</h2></header>
        <div class="body">
          <div class="chart-wrap"><canvas id="chart" width="800" height="260" aria-label="용량 예측 차트"></canvas></div>

          <!-- 간단 요약을 stat 카드로 -->
          <div class="stats">
            <div class="stat"><div class="k">첫 예측 (Ah)</div><div class="v" id="statFirst">—</div></div>
            <div class="stat"><div class="k">마지막 (Ah)</div><div class="v" id="statLast">—</div></div>
            <div class="stat"><div class="k">길이</div><div class="v" id="statLen">—</div></div>
          </div>

          <table id="tbl" aria-label="예측 테이블">
            <thead><tr><th>k</th><th>capacity_hat (Ah)</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>
      </article>
    </section>
  </main>

  <!-- onnxruntime-web (CDN 그대로 유지) -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>

  <script>
  /* ====== 경로: HTML 위치에 따라 수정하세요 ====== */
  const PATHS = {
    LGBM_V : "models/curr-life/lgbm_v.onnx",
    LGBM_IR: "models/curr-life/lgbm_ir.onnx",
    LGBM_P7: "models/curr-life/lgbm_p7.onnx",
    LGBM_P8: "models/curr-life/lgbm_p8.onnx",
    CNN    : "models/curr-life/cnn_lstm.onnx",
  };
  /* ============================================= */

  const REQ_SEQ = 100; // CNN-LSTM 학습 시퀀스 길이 (고정)
  const $ = id => document.getElementById(id);
  const q = sel => document.querySelector(sel);
  const warn = m => $("warn").textContent = m || "";

  let sv, sir, sp7, sp8, scnn;

  async function ensureSessions(){
    if (sv) return;
    // WASM 설정
    ort.env.wasm.numThreads = 3;
    ort.env.wasm.proxy = false;

    [sv, sir, sp7, sp8, scnn] = await Promise.all([
      ort.InferenceSession.create(PATHS.LGBM_V,  {executionProviders:["wasm"]}),
      ort.InferenceSession.create(PATHS.LGBM_IR, {executionProviders:["wasm"]}),
      ort.InferenceSession.create(PATHS.LGBM_P7, {executionProviders:["wasm"]}),
      ort.InferenceSession.create(PATHS.LGBM_P8, {executionProviders:["wasm"]}),
      ort.InferenceSession.create(PATHS.CNN,     {executionProviders:["wasm"]}),
    ]);
  }

  /* ========= 축/눈금/단위가 있는 커스텀 드로잉 ========= */
  let lastPlot = { series: [], opts: {} };

  function niceTicks(min, max, maxTicks=6){
    if (!Number.isFinite(min) || !Number.isFinite(max)) return {ticks:[0,1], niceMin:0, niceMax:1};
    if (min === max){ max = min + 1; }
    const span = max - min;
    const step0 = Math.pow(10, Math.floor(Math.log10(span / Math.max(1,maxTicks))));
    const err = (maxTicks * step0) / span;
    let step = step0;
    if (err <= 0.15) step = step0 * 10;
    else if (err <= 0.35) step = step0 * 5;
    else if (err <= 0.75) step = step0 * 2;

    const niceMin = Math.floor(min / step) * step;
    const niceMax = Math.ceil (max / step) * step;

    const ticks = [];
    for (let v = niceMin; v <= niceMax + 1e-9; v += step) ticks.push(v);
    return {ticks, niceMin, niceMax};
  }
  function fmtY(v, span){
    const s = Math.abs(span);
    let dec = 3;
    if (s >= 5) dec = 1;
    else if (s >= 1) dec = 2;
    else if (s >= 0.1) dec = 3;
    else dec = 4;
    return v.toFixed(dec);
  }

  function draw(series, opts={}){
    lastPlot = { series, opts };

    const c=$("chart"), ctx=c.getContext("2d"), dpr=window.devicePixelRatio||1;
    const W=c.clientWidth,H=c.clientHeight; c.width=W*dpr;c.height=H*dpr;ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.clearRect(0,0,W,H);

    if(!series || !series.length) return;

    const styles = getComputedStyle(document.body);
    const colBorder = (styles.getPropertyValue('--border') || '#e6eaf1').trim();
    const colText   = (styles.getPropertyValue('--muted')  || '#536075').trim();

    // 폰트 설정(측정 전에 세팅)
    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial';

    const xStart = Number.isFinite(+opts.xStart) ? +opts.xStart : 1;
    const xMin = xStart;
    const xMax = xStart + series.length - 1;

    const yMin = Math.min(...series);
    const yMax = Math.max(...series);
    const ySpan = (yMax - yMin) || Math.max(1e-9, Math.abs(yMax));

    const yNice = niceTicks(yMin, yMax, 6);
    const xNice = niceTicks(xMin, xMax, 6);

    const yTickLabels = yNice.ticks.map(v => fmtY(v, ySpan));
    const tickLen = 6;

    // 왼쪽 여백은 Y라벨 길이에 맞춰 자동
    const yLabelW = Math.max(...yTickLabels.map(t => ctx.measureText(t).width), 24);
    let L = 10 + tickLen + 6 + yLabelW; // 좌측 패딩 + 눈금 + 간격 + 라벨
    const T = 12;
    const R = 10;
    const B = 26 + 18; // x tick 라벨 + x축 제목 자리
    const w = Math.max(10, W - L - R);
    const h = Math.max(10, H - T - B);

    const xMapMin = xNice.ticks[0];
    const xMapMax = xNice.ticks.at(-1);
    const yMapMin = yNice.ticks[0];
    const yMapMax = yNice.ticks.at(-1);

    const X = (v) => L + ((v - xMapMin) / Math.max(1e-9, (xMapMax - xMapMin))) * w;
    const Y = (v) => T + h - ((v - yMapMin) / Math.max(1e-9, (yMapMax - yMapMin))) * h;

    // 축
    ctx.strokeStyle = colBorder; ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(L, T); ctx.lineTo(L, T + h);           // y-axis
    ctx.lineTo(L + w, T + h);                         // x-axis
    ctx.stroke();

    // Y 눈금 & 그리드
    ctx.fillStyle = colText;
    for (const v of yNice.ticks){
      const yy = Y(v);
      // 그리드
      ctx.strokeStyle = colBorder;
      ctx.beginPath(); ctx.moveTo(L, yy); ctx.lineTo(L + w, yy); ctx.stroke();
      // 틱
      ctx.strokeStyle = colText;
      ctx.beginPath(); ctx.moveTo(L - tickLen, yy); ctx.lineTo(L, yy); ctx.stroke();
      // 라벨
      const label = fmtY(v, ySpan);
      ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
      ctx.fillText(label, L - tickLen - 4, yy);
    }

    // X 눈금 & 그리드
    for (const v of xNice.ticks){
      if (v < xMin - 1e-9 || v > xMax + 1e-9) continue;
      const xx = X(v);
      // 그리드
      ctx.strokeStyle = colBorder;
      ctx.beginPath(); ctx.moveTo(xx, T); ctx.lineTo(xx, T + h); ctx.stroke();
      // 틱
      ctx.strokeStyle = colText;
      ctx.beginPath(); ctx.moveTo(xx, T + h); ctx.lineTo(xx, T + h + tickLen); ctx.stroke();
      // 라벨(정수)
      ctx.textAlign = 'center'; ctx.textBaseline = 'top';
      ctx.fillText(String(Math.round(v)), xx, T + h + tickLen + 4);
    }

    // 데이터 선
    ctx.strokeStyle = '#3b82f6';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(X(xMin), Y(series[0]));
    for (let i=1;i<series.length;i++){
      ctx.lineTo(X(xMin + i), Y(series[i]));
    }
    ctx.stroke();

    // 축 제목
    const xTitle = opts.xLabel || 'Cycle';
    const yTitle = opts.yLabel || 'Capacity (Ah)';

    ctx.fillStyle = colText;
    // X축 제목
    ctx.textAlign = 'center'; ctx.textBaseline = 'top';
    ctx.fillText(xTitle, L + w/2, T + h + tickLen + 20);

    // Y축 제목(세로)
    ctx.save();
    ctx.translate(14, T + h/2);
    ctx.rotate(-Math.PI/2);
    ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
    ctx.fillText(yTitle, 0, 0);
    ctx.restore();
  }

  // 리사이즈 시 마지막 상태로 재그리기
  window.addEventListener('resize', () => draw(lastPlot.series || [], lastPlot.opts || {}));

  /* ========= 원래 로직 ========= */
  function mkFeatsTensor(c1,pct01,c2,cy){
    return new ort.Tensor('float32', new Float32Array([c1,pct01,c2,cy]), [1,4]);
  }

  async function lgbmStep(c1,pct01,c2,cy){
    const v  = (await sv .run({ [sv .inputNames[0]]: mkFeatsTensor(c1,pct01,c2,cy) }))[sv .outputNames[0]].data[0];
    const ir = (await sir.run({ [sir.inputNames[0]]: mkFeatsTensor(c1,pct01,c2,cy) }))[sir.outputNames[0]].data[0];
    const p7 = (await sp7.run({ [sp7.inputNames[0]]: mkFeatsTensor(c1,pct01,c2,cy) }))[sp7.outputNames[0]].data[0];
    const p8 = (await sp8.run({ [sp8.inputNames[0]]: mkFeatsTensor(c1,pct01,c2,cy) }))[sp8.outputNames[0]].data[0];
    return {v, ir, p7, p8};
  }

  function makeCnnFeeds(V,IR,P7,P8){
    const seq = REQ_SEQ;
    const t = arr => new ort.Tensor('float32', Float32Array.from(arr), [1, seq, 1]);
    const feeds = {};
    for(const name of scnn.inputNames){
      const up = name.toUpperCase();
      if(up.includes('P7')) feeds[name]=t(P7);
      else if(up.includes('P8')) feeds[name]=t(P8);
      else if(up.includes('R')) feeds[name]=t(IR);
      else feeds[name]=t(V);
    }
    return feeds;
  }

  async function run(){
    try{
      warn(""); await ensureSessions();

      const C1  = +$("C1").value;
      const PCT = +$("PCT").value;           // %
      const C2  = +$("C2").value;
      const CY0 = Math.round(+$("CY0").value||1);
      let   SEQ = Math.round(+$("SEQ").value||100);
      const STEPS = Math.max(1, Math.round(+$("STEPS").value||800));
      const C0  = +$("C0").value;
      const EOL = Math.min(1, Math.max(0.5, +$("EOL").value||0.8));

      if(!Number.isFinite(C1)||!Number.isFinite(PCT)||!Number.isFinite(C2)||!Number.isFinite(C0)){
        warn("C1, Percentage, C2, C₀를 모두 입력하세요."); return;
      }
      const pct01 = PCT/100.0;

      // SEQ 강제 100 (모델 고정)
      if(SEQ !== REQ_SEQ){
        SEQ = REQ_SEQ; $("SEQ").value = String(REQ_SEQ);
        warn("모델이 SEQ=100으로 학습되어 입력값을 100으로 강제했습니다.");
      } else { warn(""); }

      // 1) 초기 100스텝 시퀀스 생성
      let V=[], IR=[], P7=[], P8=[];
      for(let i=0;i<SEQ;i++){
        const cy = CY0 + i;
        const o = await lgbmStep(C1, pct01, C2, cy);
        V.push(o.v); IR.push(o.ir); P7.push(o.p7); P8.push(o.p8);
      }

      // 2) 롤아웃
      let capAh = [];
      let scaleA=null, offsetB=0, recal=false;
      for(let k=0;k<STEPS;k++){
        const out = await scnn.run(makeCnnFeeds(V,IR,P7,P8));
        const yNorm = out[scnn.outputNames[0]].data[0];

        // 1점 앵커링
        if(k===0){
          scaleA = C0 / (Math.abs(yNorm)>1e-12 ? yNorm : 1e-12);
          offsetB = 0;
        }
        let c = scaleA*yNorm + offsetB;
        capAh.push(c);

        // 2점 앵커(옵션): EOL 도달 시 재보정(한 번)
        if($("anchor").value==="two" && !recal && c <= EOL*C0){
          const s0 = capAh[0]/scaleA;   // 초기 정규화 값 근사
          const sE = yNorm;             // 현재 정규화 값
          const a = (C0 - EOL*C0) / (s0 - sE + 1e-12);
          const b = C0 - a*s0;
          capAh = capAh.map((v,i)=> a*((i===0)? s0 : (v/scaleA)) + b);
          scaleA=a; offsetB=b; recal=true;
        }

        // 다음 스텝: Cycle 증가 → 특성 예측 → 시퀀스 슬라이드
        const cyNext = CY0 + SEQ + k;
        const nxt = await lgbmStep(C1, pct01, C2, cyNext);
        V.push(nxt.v); IR.push(nxt.ir); P7.push(nxt.p7); P8.push(nxt.p8);
        V.shift(); IR.shift(); P7.shift(); P8.shift();

        // EOL 도달 시 조기 종료
        if(c <= EOL*C0) break;
      }

      // 3) 렌더링/요약/테이블
      draw(capAh, {
        xStart: CY0 + SEQ,       // 첫 예측이 시작되는 사이클 번호
        xLabel: 'Cycle',         // X축 제목
        yLabel: 'Capacity (Ah)', // Y축 제목(단위 포함)
      });

      const first = capAh.length ? capAh[0] : NaN;
      const last  = capAh.length ? capAh.at(-1) : NaN;

      $("statFirst").textContent = Number.isFinite(first)? first.toFixed(6) : '—';
      $("statLast").textContent  = Number.isFinite(last)?  last.toFixed(6)  : '—';
      $("statLen").textContent   = String(capAh.length||0);

      const tb = q('#tbl tbody');
      tb.innerHTML = '';
      capAh.forEach((y,i)=>{
        const tr=document.createElement('tr');
        tr.innerHTML=`<td>${i+1}</td><td>${y.toFixed(8)}</td>`;
        tb.appendChild(tr);
      });

      // 실행 후 (SEQ 강제 등) 값 저장 동기화
      saveState();

    }catch(e){
      console.error(e);
      warn("실행 중 오류: "+(e?.message||e));
    }
  }

  // ===== 입력값 저장/복원 =====
  const LS_KEY = 'currlife:inputs:v1';
  const FIELDS = ['C1','PCT','C2','CY0','SEQ','STEPS','C0','anchor','EOL'];

  function collectState(){
    const s = {};
    for(const id of FIELDS){
      const el = $(id);
      if(!el) continue;
      s[id] = el.value ?? '';
    }
    return s;
  }
  function saveState(){
    try{ localStorage.setItem(LS_KEY, JSON.stringify(collectState())); }catch(e){}
  }
  function restoreState(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(!raw) return;
      const s = JSON.parse(raw);
      if(s && typeof s === 'object'){
        for(const id of FIELDS){
          if(Object.prototype.hasOwnProperty.call(s,id) && $(id)){
            $(id).value = s[id];
          }
        }
      }
    }catch(e){}
  }
  function bindAutosave(){
    for(const id of FIELDS){
      const el = $(id);
      if(!el) continue;
      el.addEventListener('input', saveState);
      el.addEventListener('change', saveState);
    }
  }

  // 이벤트
  $("runBtn").addEventListener("click", run);
  $("demoBtn").addEventListener("click", ()=>{
    $("C1").value="1.0"; $("PCT").value="90"; $("C2").value="0.5"; $("CY0").value="1";
    $("SEQ").value="100"; $("STEPS").value="800"; $("C0").value="2.30"; $("anchor").value="first"; $("EOL").value="0.80";
    saveState();
    warn("");
  });
  $("clearBtn").addEventListener("click", ()=>{
    for(const id of ["C1","PCT","C2","CY0","SEQ","STEPS","C0"]) $(id).value="";
    // anchor/EOL은 유지(필요 시 아래 두 줄 주석 해제)
    // $("anchor").value="first"; $("EOL").value="0.80";

    draw([], { xLabel: 'Cycle', yLabel: 'Capacity (Ah)' });
    const tb = q('#tbl tbody'); tb.innerHTML = '';
    $("statFirst").textContent=$("statLast").textContent=$("statLen").textContent="—";
    saveState();
    warn("");
  });

  // 초기: 복원 → 자동저장 바인딩 → 페이지 이탈 시 저장
  restoreState();
  bindAutosave();
  window.addEventListener('beforeunload', saveState);
  </script>
</body>
</html>
